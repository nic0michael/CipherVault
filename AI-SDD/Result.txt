### 1. `VaultEntity.java`

```java
package com.ciphervault.fullservice.entity;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "vault_entries")
public class VaultEntity {

    @Id
    @GeneratedValue
    private UUID id;

    private String title;
    private String username;
    private String password; // Encrypted
    private String url;
    private String notes;
    private String folder;

    // Constructors
    public VaultEntity() {}

    public VaultEntity(String title, String username, String password, String url, String notes, String folder) {
        this.title = title;
        this.username = username;
        this.password = password;
        this.url = url;
        this.notes = notes;
        this.folder = folder;
    }

    // Getters & Setters
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    public String getFolder() { return folder; }
    public void setFolder(String folder) { this.folder = folder; }
}
```

---

### 2. `VaultDAO.java`

```java
package com.ciphervault.fullservice.dao;

import java.util.UUID;

public class VaultDAO {
    private UUID id;
    private String title;
    private String username;
    private String password;
    private String url;
    private String notes;
    private String folder;

    // Constructors
    public VaultDAO() {}
    
    public VaultDAO(UUID id, String title, String username, String password, String url, String notes, String folder) {
        this.id = id;
        this.title = title;
        this.username = username;
        this.password = password;
        this.url = url;
        this.notes = notes;
        this.folder = folder;
    }

    // Getters & Setters
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    public String getFolder() { return folder; }
    public void setFolder(String folder) { this.folder = folder; }
}
```

---

### 3. `VaultRequest.java`

```java
package com.ciphervault.fullservice.request;

public class VaultRequest {
    private String title;
    private String username;
    private String password;
    private String url;
    private String notes;
    private String folder;

    // Getters & Setters
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    public String getFolder() { return folder; }
    public void setFolder(String folder) { this.folder = folder; }
}
```

---

### 4. `VaultResponse.java`

```java
package com.ciphervault.fullservice.response;

import java.util.UUID;

public class VaultResponse {
    private UUID id;
    private String title;
    private String username;
    private String password;
    private String url;
    private String notes;
    private String folder;

    // Constructors
    public VaultResponse() {}

    public VaultResponse(UUID id, String title, String username, String password, String url, String notes, String folder) {
        this.id = id;
        this.title = title;
        this.username = username;
        this.password = password;
        this.url = url;
        this.notes = notes;
        this.folder = folder;
    }

    // Getters & Setters
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    public String getFolder() { return folder; }
    public void setFolder(String folder) { this.folder = folder; }
}
```

---

### 5. `VaultListResponse.java`

```java
package com.ciphervault.fullservice.response;

import java.util.List;

public class VaultListResponse {
    private List<VaultResponse> entries;

    public VaultListResponse() {}
    public VaultListResponse(List<VaultResponse> entries) {
        this.entries = entries;
    }

    public List<VaultResponse> getEntries() { return entries; }
    public void setEntries(List<VaultResponse> entries) { this.entries = entries; }
}
```

---

### 6. `IntializeProjectResponse.java`

```java
package com.ciphervault.fullservice.response;

public class IntializeProjectResponse {
    private String passwordSalt;
    private String encryptionSalt;
    private String message;

    public IntializeProjectResponse() {}
    public IntializeProjectResponse(String passwordSalt, String encryptionSalt, String message) {
        this.passwordSalt = passwordSalt;
        this.encryptionSalt = encryptionSalt;
        this.message = message;
    }

    public String getPasswordSalt() { return passwordSalt; }
    public void setPasswordSalt(String passwordSalt) { this.passwordSalt = passwordSalt; }

    public String getEncryptionSalt() { return encryptionSalt; }
    public void setEncryptionSalt(String encryptionSalt) { this.encryptionSalt = encryptionSalt; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
```

---

### 7. `LogResponse.java`

```java
package com.ciphervault.fullservice.response;

public class LogResponse {
    private boolean success;
    private String sessionToken;
    private String message;

    public LogResponse() {}
    public LogResponse(boolean success, String sessionToken, String message) {
        this.success = success;
        this.sessionToken = sessionToken;
        this.message = message;
    }

    public boolean isSuccess() { return success; }
    public void setSuccess(boolean success) { this.success = success; }

    public String getSessionToken() { return sessionToken; }
    public void setSessionToken(String sessionToken) { this.sessionToken = sessionToken; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
```

---

### 8. `VaultService.java`

```java
package com.ciphervault.fullservice.service;

import com.ciphervault.fullservice.request.VaultRequest;
import com.ciphervault.fullservice.response.*;

public interface VaultService {
    IntializeProjectResponse initializeProject(String masterPassword);
    LogResponse login(String masterPassword);
    VaultResponse createEntry(VaultRequest entry);
    VaultResponse getEntry(String entryName);
    VaultListResponse getEntryList();
    VaultListResponse searchEntryList(String entryName);
}
```

---

### 9. `VaultServiceImpl.java`

```java
package com.ciphervault.fullservice.service;

import com.ciphervault.fullservice.request.VaultRequest;
import com.ciphervault.fullservice.response.*;
import org.springframework.stereotype.Service;

import java.util.Collections;

@Service
public class VaultServiceImpl implements VaultService {

    @Override
    public IntializeProjectResponse initializeProject(String masterPassword) {
        // TODO: Implement Argon2id + AES key generation
        return new IntializeProjectResponse("dummyPasswordSalt", "dummyEncryptionSalt", "Project initialized successfully");
    }

    @Override
    public LogResponse login(String masterPassword) {
        // TODO: Implement login check
        return new LogResponse(true, "dummySessionToken", "Login successful");
    }

    @Override
    public VaultResponse createEntry(VaultRequest entry) {
        // TODO: Persist VaultEntity to DB
        return new VaultResponse(null, entry.getTitle(), entry.getUsername(), entry.getPassword(), entry.getUrl(), entry.getNotes(), entry.getFolder());
    }

    @Override
    public VaultResponse getEntry(String entryName) {
        // TODO: Fetch VaultEntity by name from DB
        return new VaultResponse(null, entryName, "dummyUser", "dummyPassword", "https://example.com", "dummyNotes", "default");
    }

    @Override
    public VaultListResponse getEntryList() {
        // TODO: Fetch all entries
        return new VaultListResponse(Collections.emptyList());
    }

    @Override
    public VaultListResponse searchEntryList(String entryName) {
        // TODO: Search entries by name
        return new VaultListResponse(Collections.emptyList());
    }
}
```

---

### 10. `VaultController.java`

```java
package com.ciphervault.fullservice.controller;

import com.ciphervault.fullservice.request.VaultRequest;
import com.ciphervault.fullservice.response.*;
import com.ciphervault.fullservice.service.VaultService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/vault")
public class VaultController {

    @Autowired
    private VaultService vaultService;

    @PostMapping("/initialize")
    public IntializeProjectResponse initializeProject(@RequestParam String masterPassword) {
        return vaultService.initializeProject(masterPassword);
    }

    @PostMapping("/login")
    public LogResponse login(@RequestParam String masterPassword) {
        return vaultService.login(masterPassword);
    }

    @PostMapping("/entries")
    public VaultResponse createEntry(@RequestBody VaultRequest entry) {
        return vaultService.createEntry(entry);
    }

    @GetMapping("/entries/{entryName}")
    public VaultResponse getEntry(@PathVariable String entryName) {
        return vaultService.getEntry(entryName);
    }

    @GetMapping("/entries")
    public VaultListResponse getEntryList() {
        return vaultService.getEntryList();
    }

    @GetMapping("/search")
    public VaultListResponse searchEntryList(@RequestParam String entryName) {
        return vaultService.searchEntryList(entryName);
    }
}
```

---

✅ This is a **full set of Spring Boot classes** ready to compile and extend.

Next steps:

* Wire `VaultEntity` to **PostgreSQL** with a `JpaRepository`.
* Implement **encryption via CipherVaultCommon** before persisting passwords.
* Implement **Argon2id hashing for master password** and session handling.

---

=============


### 1. `VaultRepository.java`

```java
package com.ciphervault.fullservice.repository;

import com.ciphervault.fullservice.entity.VaultEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface VaultRepository extends JpaRepository<VaultEntity, UUID> {

    Optional<VaultEntity> findByTitle(String title);

    List<VaultEntity> findByTitleContainingIgnoreCase(String title);
}
```

---

### 2. Update `VaultServiceImpl.java` to use `VaultRepository`

```java
package com.ciphervault.fullservice.service;

import com.ciphervault.fullservice.entity.VaultEntity;
import com.ciphervault.fullservice.repository.VaultRepository;
import com.ciphervault.fullservice.request.VaultRequest;
import com.ciphervault.fullservice.response.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class VaultServiceImpl implements VaultService {

    @Autowired
    private VaultRepository vaultRepository;

    @Override
    public IntializeProjectResponse initializeProject(String masterPassword) {
        // TODO: Implement Argon2id + AES key generation
        return new IntializeProjectResponse("dummyPasswordSalt", "dummyEncryptionSalt", "Project initialized successfully");
    }

    @Override
    public LogResponse login(String masterPassword) {
        // TODO: Implement login check
        return new LogResponse(true, "dummySessionToken", "Login successful");
    }

    @Override
    public VaultResponse createEntry(VaultRequest entry) {
        // TODO: Encrypt password before saving using CipherVaultCommon
        VaultEntity entity = new VaultEntity(
                entry.getTitle(),
                entry.getUsername(),
                entry.getPassword(), // encrypted in real implementation
                entry.getUrl(),
                entry.getNotes(),
                entry.getFolder()
        );
        VaultEntity saved = vaultRepository.save(entity);
        return mapToResponse(saved);
    }

    @Override
    public VaultResponse getEntry(String entryName) {
        return vaultRepository.findByTitle(entryName)
                .map(this::mapToResponse)
                .orElse(null);
    }

    @Override
    public VaultListResponse getEntryList() {
        List<VaultEntity> entities = vaultRepository.findAll();
        List<VaultResponse> responses = entities.stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
        return new VaultListResponse(responses);
    }

    @Override
    public VaultListResponse searchEntryList(String entryName) {
        List<VaultEntity> entities = vaultRepository.findByTitleContainingIgnoreCase(entryName);
        List<VaultResponse> responses = entities.stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
        return new VaultListResponse(responses);
    }

    // Helper: map VaultEntity -> VaultResponse
    private VaultResponse mapToResponse(VaultEntity entity) {
        return new VaultResponse(
                entity.getId(),
                entity.getTitle(),
                entity.getUsername(),
                entity.getPassword(), // decrypt if needed
                entity.getUrl(),
                entity.getNotes(),
                entity.getFolder()
        );
    }
}
```

---

### ✅ What’s now ready

* **VaultRepository** handles PostgreSQL persistence.
* **VaultServiceImpl** now fully uses repository methods for CRUD.
* Search and list endpoints work using `JpaRepository`.
* Encryption/decryption and session handling can be plugged in via **CipherVaultCommon**.

---

============

---

### 1. `EncryptionManager.java`

```java
package com.ciphervault.common;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

import de.mkammerer.argon2.Argon2Factory;
import de.mkammerer.argon2.Argon2;

public class EncryptionManager {

    private static final int AES_KEY_SIZE = 256;
    private static final int GCM_NONCE_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;

    private static final SecureRandom secureRandom = new SecureRandom();

    /** Hash master password with Argon2id */
    public static String hashPassword(String password, String saltBase64) {
        Argon2 argon2 = Argon2Factory.create();
        byte[] salt = Base64.getDecoder().decode(saltBase64);
        return argon2.hash(3, 65536, 1, (password + new String(salt)).toCharArray());
    }

    /** Verify Argon2id hashed password */
    public static boolean verifyPassword(String hash, String password, String saltBase64) {
        Argon2 argon2 = Argon2Factory.create();
        byte[] salt = Base64.getDecoder().decode(saltBase64);
        return argon2.verify(hash, (password + new String(salt)).toCharArray());
    }

    /** AES-256-GCM Encryption */
    public static String encrypt(String plainText, SecretKey key) throws Exception {
        byte[] nonce = new byte[GCM_NONCE_LENGTH];
        secureRandom.nextBytes(nonce);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        byte[] encrypted = cipher.doFinal(plainText.getBytes());

        byte[] combined = new byte[nonce.length + encrypted.length];
        System.arraycopy(nonce, 0, combined, 0, nonce.length);
        System.arraycopy(encrypted, 0, combined, nonce.length, encrypted.length);

        return Base64.getEncoder().encodeToString(combined);
    }

    /** AES-256-GCM Decryption */
    public static String decrypt(String cipherTextBase64, SecretKey key) throws Exception {
        byte[] combined = Base64.getDecoder().decode(cipherTextBase64);
        byte[] nonce = new byte[GCM_NONCE_LENGTH];
        byte[] cipherText = new byte[combined.length - GCM_NONCE_LENGTH];

        System.arraycopy(combined, 0, nonce, 0, GCM_NONCE_LENGTH);
        System.arraycopy(combined, GCM_NONCE_LENGTH, cipherText, 0, cipherText.length);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);

        return new String(cipher.doFinal(cipherText));
    }

    /** Generate AES-256 key from session key bytes */
    public static SecretKey generateAESKey(byte[] keyBytes) {
        return new SecretKeySpec(keyBytes, "AES");
    }

    /** Generate random salt, Base64 encoded */
    public static String generateSalt(int length) {
        byte[] salt = new byte[length];
        secureRandom.nextBytes(salt);
        return Base64.getEncoder().encodeToString(salt);
    }
}
```

---

### 2. `MetadataManager.java`

```java
package com.ciphervault.common;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.util.Map;

public class MetadataManager {

    private static final ObjectMapper mapper = new ObjectMapper();
    private static final String METADATA_FILE = "./config/metadata.json";

    public static void saveMetadata(Map<String, String> metadata) throws Exception {
        File file = new File(METADATA_FILE);
        file.getParentFile().mkdirs();
        mapper.writeValue(file, metadata);
    }

    public static Map<String, String> loadMetadata() throws Exception {
        File file = new File(METADATA_FILE);
        if (!file.exists()) return null;
        return mapper.readValue(file, Map.class);
    }
}
```

---

### ✅ Integration Points

* **VaultServiceImpl#createEntry** → encrypt the password using `EncryptionManager.encrypt()`.
* **VaultServiceImpl#getEntry** → decrypt using `EncryptionManager.decrypt()`.
* **initializeProject** → generate password salt and encryption salt via `EncryptionManager.generateSalt()` and save via `MetadataManager.saveMetadata()`.
* **login** → verify Argon2id hashed master password using `EncryptionManager.verifyPassword()`.

---
====================
This gives you a **complete CipherVaultCommon cryptography stub** ready to integrate with your `VaultService` and controller.

I can now **update your `VaultServiceImpl` to fully use this encryption flow for password hashing and vault entry encryption/decryption**.

REVISED VaultServiceImpl
================================

Perfect! Let’s revise `VaultServiceImpl` to fully integrate with the **CipherVaultCommon** encryption and metadata utilities. This will handle:

* **Project initialization** (generate salts, create metadata)
* **Master password verification**
* **Vault entry encryption/decryption**
* **CRUD operations** for entries

---

### `VaultServiceImpl.java`

```java
package com.ciphervault.fullservice.ciphervault.service;

import com.ciphervault.fullservice.ciphervault.dao.VaultDAO;
import com.ciphervault.fullservice.ciphervault.entity.VaultEntity;
import com.ciphervault.fullservice.ciphervault.request.VaultRequest;
import com.ciphervault.fullservice.ciphervault.response.*;
import com.ciphervault.fullservice.ciphervault.repository.VaultRepository;
import com.ciphervault.common.EncryptionManager;
import com.ciphervault.common.MetadataManager;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class VaultServiceImpl implements VaultService {

    @Autowired
    private VaultRepository vaultRepository;

    private String passwordHash;
    private String passwordSalt;
    private String encryptionSalt;

    /** Initialize project: generate salts, store metadata, prepare DB */
    @Override
    public IntializeProjectResponse initializeProject(String masterPassword) {
        try {
            // Generate salts
            passwordSalt = EncryptionManager.generateSalt(16);
            encryptionSalt = EncryptionManager.generateSalt(16);

            // Hash master password
            passwordHash = EncryptionManager.hashPassword(masterPassword, passwordSalt);

            // Save metadata
            Map<String, String> metadata = new HashMap<>();
            metadata.put("version", "1.0");
            metadata.put("kdf", "argon2id");
            metadata.put("password_salt", passwordSalt);
            metadata.put("encryption_salt", encryptionSalt);

            MetadataManager.saveMetadata(metadata);

            return new IntializeProjectResponse(true, "Project initialized. Save your salts!", passwordSalt, encryptionSalt);

        } catch (Exception e) {
            return new IntializeProjectResponse(false, "Initialization failed: " + e.getMessage(), null, null);
        }
    }

    /** Verify master password for login */
    @Override
    public LogResponse login(String masterPassword) {
        try {
            Map<String, String> metadata = MetadataManager.loadMetadata();
            if (metadata == null) return new LogResponse(false, "Metadata not found. Initialize first!");

            passwordSalt = metadata.get("password_salt");
            encryptionSalt = metadata.get("encryption_salt");
            passwordHash = EncryptionManager.hashPassword(masterPassword, passwordSalt);

            boolean verified = EncryptionManager.verifyPassword(passwordHash, masterPassword, passwordSalt);
            return new LogResponse(verified, verified ? "Login successful" : "Invalid password");

        } catch (Exception e) {
            return new LogResponse(false, "Login error: " + e.getMessage());
        }
    }

    /** Create a vault entry with encrypted password */
    @Override
    public VaultResponse createEntry(VaultRequest request) {
        try {
            // Load encryption key
            SecretKey key = EncryptionManager.generateAESKey(encryptionSalt.getBytes());

            // Encrypt password
            String encryptedPassword = EncryptionManager.encrypt(request.getPassword(), key);

            // Persist entity
            VaultEntity entity = new VaultEntity();
            entity.setTitle(request.getTitle());
            entity.setUsername(request.getUsername());
            entity.setPassword(encryptedPassword);
            entity.setUrl(request.getUrl());
            entity.setNotes(request.getNotes());
            entity.setFolder(request.getFolder());

            vaultRepository.save(entity);

            return new VaultResponse(true, "Entry created successfully", entity);

        } catch (Exception e) {
            return new VaultResponse(false, "Create entry failed: " + e.getMessage(), null);
        }
    }

    /** Get a single vault entry by title, decrypting password */
    @Override
    public VaultResponse getEntry(String entryName) {
        try {
            VaultEntity entity = vaultRepository.findByTitle(entryName);
            if (entity == null) return new VaultResponse(false, "Entry not found", null);

            SecretKey key = EncryptionManager.generateAESKey(encryptionSalt.getBytes());
            entity.setPassword(EncryptionManager.decrypt(entity.getPassword(), key));

            return new VaultResponse(true, "Entry retrieved", entity);

        } catch (Exception e) {
            return new VaultResponse(false, "Get entry failed: " + e.getMessage(), null);
        }
    }

    /** Get all vault entries, decrypt passwords */
    @Override
    public VaultListResponse getEntryList() {
        try {
            List<VaultEntity> entities = vaultRepository.findAll();
            SecretKey key = EncryptionManager.generateAESKey(encryptionSalt.getBytes());

            List<VaultDAO> list = entities.stream().map(e -> {
                try {
                    e.setPassword(EncryptionManager.decrypt(e.getPassword(), key));
                } catch (Exception ex) {
                    e.setPassword(null);
                }
                return new VaultDAO(e);
            }).collect(Collectors.toList());

            return new VaultListResponse(true, "All entries retrieved", list);

        } catch (Exception e) {
            return new VaultListResponse(false, "Get entry list failed: " + e.getMessage(), null);
        }
    }

    /** Search vault entries by title substring */
    @Override
    public VaultListResponse searchEntryList(String entryName) {
        try {
            List<VaultEntity> entities = vaultRepository.findByTitleContaining(entryName);
            SecretKey key = EncryptionManager.generateAESKey(encryptionSalt.getBytes());

            List<VaultDAO> list = entities.stream().map(e -> {
                try {
                    e.setPassword(EncryptionManager.decrypt(e.getPassword(), key));
                } catch (Exception ex) {
                    e.setPassword(null);
                }
                return new VaultDAO(e);
            }).collect(Collectors.toList());

            return new VaultListResponse(true, "Search results", list);

        } catch (Exception e) {
            return new VaultListResponse(false, "Search failed: " + e.getMessage(), null);
        }
    }
}
```

---

### ✅ Notes on Implementation

1. **Metadata loading/saving** – uses `MetadataManager` to persist salts in `/config/metadata.json`.
2. **Password hashing** – Argon2id with `EncryptionManager.hashPassword()`.
3. **AES-256 encryption** – uses `encryptionSalt` to derive `SecretKey`.
4. **CRUD operations** – encrypt password on save, decrypt on retrieval.
5. **VaultDAO mapping** – converts `VaultEntity` to DTO for API responses.

---

Next step: I can generate the **Spring Data `VaultRepository` interface** with the required query methods (`findByTitle`, `findByTitleContaining`) so this service is fully functional with PostgreSQL.

================================




